# JUnit-Testing

**Ensuring code, program, or software is functional and secure** – To ensure this program met requirements, I used the best coding practices. I used easy to comprehend names for methods and classes, with inline comments to help viewers understand what each segment of code is responsible for. I ran multiple JUnit tests, which tested each method created to ensure they met client expectations. An example of client requirements for this project includes data entry for a method to be under a set number of characters, can delete, alter, or add data. For each method I ran a test to ensure the character requirement couldn’t be surpassed, and a test that an entry could be added, deleted, and altered. Regression testing was incorporated as well, to verify that newly added portions of code did not render older portions obsolete. Using regression testing helps to ensure that there are no potential errors or bugs within a program. Lastly, I ran an overall coverage test to validate that the JUnit tests were effective. All tests came back at 93% or higher, which are phenomenal percentages to prove the effectiveness of the program. This rigorous testing was time consuming, but ultimately ensures the software is functional and secure.

**Interpreting user needs and incorporating them into a program** – When understanding a user’s needs and incorporating them into a program, it is important to have a thorough understanding of what the program is meant to accomplish. Once you have that deep rooted understanding, you can start to consider what issues users can potentially run into. A good example of this would be ensuring that data entries cannot have duplicate ID numbers. Each ID must be unique and under 10 characters. To prevent this issue, we can prevent duplicate IDs from being created by not allowing that field to be altered. This ensures that each user ID will be unique. Another potential issue would be a user entering an invalid phone number. To prevent this from happening, we set a character limit to the phone number to verify that there are no extra or missing numbers. If we wanted to go more in depth, we could even set up a parameter to verify that all phone number characters are digits. The next logical step would be to run a JUnit test to verify that all characters are numeric and to throw an error if there is an alphabet letter entered. These are just a few examples of many ways to interpret user needs.

**Approaching software design** – I approach software design in a few stages. Firstly, I will get an understanding of the project by considering functions, requirements, and outcomes. This will help me to work up a basic UML diagram to start a gameplan of what steps need to be taken and in which order.  Secondly, I will take a computational approach by meeting each requirement one at a time without any biases or preferences. Start with an object until it is finished and keep building on until all objects are completed. Once all objects are completed, the third stage starts where tests are created to ensure the validity of each object. Again, this takes a computational approach to just complete all the tasks in order. After all tests are completed and run, I’ll verify that nothing was left out. The fourth stage is the fun stage, this is where I know that I have a completed program and have verified everything works according to client expectations and error have been eliminated. At this point I’ll go in and make sure inline comments do an adequate job of explaining each portion of code. Then my favorite part is cleaning the code up. I’ll see if there are other methods or options to use in place of what I’ve already implemented. If I find a new method that works, I’ll change out the old and verify that this doesn’t create errors with the use of regression testing.
